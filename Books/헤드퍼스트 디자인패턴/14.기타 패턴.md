## 브리지 패턴

- 구현과 더불어 추상화 부분까지 변경해야 할 경우.
- 활용법: 여러 플랫폼에서 사용해야 하는 그래픽스와 윈도우 처리 시스템에서 유용하게 사용.
- 장점: 구현과 인터페이스를 완전히 결합하지 않았기에 구현과 추상화 부분을 분리할 수 있다.
- 단점: 복잡해진다.

## 빌더 패턴

- 제품을 여러 단계로 나눠서 만들도록 제품 생산 단계를 캡슐화하고 싶을 경우.
- 활용법: 복합 객체 구조를 구축하는 용도로 많이 사용.
- 장점: 제품의 내부 구조를 클라이언트로부터 보호할 수 있다.
- 단점: 팩토리를 사용할 때 보다 객체를 만들 때 클라이언트에 관해 더 많이 알아야 한다.

## 책임 연쇄 패턴

- 1개의 요청을 2개 이상의 객체에서 처리해야 할 경우.
- 활용법: 윈도우 시스템에서 마우스 클릭과 키보드 이벤트를 처리할 때 사용.
- 장점: 객체는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는 다른 객체의 직접적인 레퍼런스를 가질 필요도 없으므로 객체를 단순하게 만들 수 있다.
- 단점: 요청이 반드시 수행된다는 보장이 없고, 실행 시에 과정을 살펴보거나 디버깅하기가 힘들다.

## 플라이웨이트 패턴

- flyweight: 경량.
- 어떤 클래스의 인스턴스 하나로 여러 개의 '가상 인스턴스'를 제공할 경우.
- 사용법: 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어해야 할 때 유용하게 사용.
- 장점: 실행 시에 객체 인스턴스의 개수를 줄여서 메모리를 절약할 수 있다.
- 단점: 특정 인스턴스만 다른 인스턴스와 다르게 행동하게 할 수 없다.

## 인터프리터 패턴

- interpreter: 해석기.
- 어떤 언어의 인터프리터를 만들 경우.
- 활용법: 간단한 언어를 구현할 때 인터프리터 패턴이 유용하다.
- 장점: 문법을 클래스로 표현해서 쉽게 언어를 구현할 수 있다.
- 단점: 문법 규칙의 개수가 많아지면 아주 복잡해진다.

## 중재자 패턴

- 서로 관련된 객체 사이의 복잡한 통신과 제어를 한곳으로 집중할 경우.
- 활용법: 서로 연관된 GUI 구성 요소를 관리하는 용도로 사용.
- 장점: 시스템과 객체를 분리함으로써 재사용성을 획기적으로 향상시킬 수 있다.
- 단점: 디자인을 잘 하지 못하면 중재자 객체가 너무 복잡해질 수 있다.

## 메멘토 패턴

- memento: 기억의 증표.
- 객체를 이전의 상태로 복구해야 할 경우.
- 활용법: 메멘토 객체를 써서 상태를 저장한다.
- 장점: 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어 안전하다.
- 단점: 상태를 저장하고 복구하는 데 시간이 오래 걸리 수 있다.

## 프로토타입 패턴

- 어떤 클래스의 인스턴스를 만들 때 자원과 시간이 많이 들거나 복잡할 경우.
- 활용법: 시스템에서 복잡한 클래스 계층구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 새로 만들어야 할 때 유용하게 사용.
- 장점: 클라이언트는 새로운 인스턴스를 만드는 과정을 몰라도 된다.
- 단점: 때때로 객체의 복사본을 만드는 일이 매우 복잡할 수도 있다.

## 비지터 패턴

- 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않을 경우.
- 장점: 구조를 변경하지 않으면서도 복합 객체 구조에 새로운 기능을 추가할 수 있다.
- 단점: 복합 클래스의 캡슐화가 깨진다.
